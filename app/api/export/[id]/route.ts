import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'
import JSZip from 'jszip'
import { readFileSync } from 'fs'
import { join } from 'path'

// GET /api/export/[id]
export async function GET(
  req: Request,
  { params }: { params: { id: string } }
) {
  return handleExport(params.id)
}

async function handleExport(sessionId: string) {
  try {
    console.log('[EXPORT] Starting export for session:', sessionId)

    // 1. Authenticate
    const supabase = createRouteHandlerClient({ cookies })
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError) {
      console.error('[EXPORT] Auth error:', authError)
      return NextResponse.json({ error: 'Authentication failed', details: authError.message }, { status: 401 })
    }

    if (!user) {
      console.error('[EXPORT] No user found')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    console.log('[EXPORT] Authenticated user:', user.id)

    // 2. Validate session ID
    if (!sessionId) {
      console.error('[EXPORT] No session ID provided')
      return NextResponse.json({ error: 'Session ID required' }, { status: 400 })
    }

    // 3. Check rate limiting (5 exports per day)
    console.log('[EXPORT] Checking rate limits...')
    const { count } = await supabase
      .from('exports')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', user.id)
      .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString())

    console.log('[EXPORT] Export count in last 24h:', count || 0)

    if (count && count >= 5) {
      console.error('[EXPORT] Rate limit exceeded:', count)
      return NextResponse.json(
        { error: 'Export limit reached. Maximum 5 exports per 24 hours.' },
        { status: 429 }
      )
    }

    // 4. Fetch approved plan from database
    console.log('[EXPORT] Fetching approved plan...')
    const { data: plan, error: planError } = await supabase
      .from('plans')
      .select('id, content, edited_content, status')
      .eq('session_id', sessionId)
      .single()

    if (planError) {
      console.error('[EXPORT] Error fetching plan:', planError)
      return NextResponse.json({
        error: 'Failed to fetch plan',
        details: planError.message
      }, { status: 500 })
    }

    if (!plan) {
      console.error('[EXPORT] No plan found for session:', sessionId)
      return NextResponse.json({
        error: 'Plan not found. Please generate and approve a plan first.'
      }, { status: 404 })
    }

    console.log('[EXPORT] Plan found:', {
      id: plan.id,
      status: plan.status,
      hasContent: !!plan.content,
      hasEditedContent: !!plan.edited_content,
      contentLength: plan.content?.length || 0,
      editedContentLength: plan.edited_content?.length || 0
    })

    if (plan.status !== 'approved') {
      console.error('[EXPORT] Plan not approved. Status:', plan.status)
      return NextResponse.json(
        { error: `Plan status is '${plan.status}'. Please review and approve your plan first.` },
        { status: 400 }
      )
    }

    // Use edited content if available, otherwise use original content
    const buildingPlan = plan.edited_content || plan.content
    console.log('[EXPORT] Using building plan:', {
      source: plan.edited_content ? 'edited_content' : 'content',
      length: buildingPlan.length,
      preview: buildingPlan.substring(0, 200) + '...'
    })

    // 5. Call Claude to transform plan into files
    console.log('[EXPORT] Calling Claude to generate export files...')
    const files = await callClaude(buildingPlan)

    console.log('[EXPORT] Claude generation complete:', {
      hasReadme: !!files.readme,
      hasClaude: !!files.claude,
      modulesCount: Object.keys(files.modules).length,
      promptsCount: Object.keys(files.prompts).length
    })

    if (!files.readme && !files.claude) {
      console.error('[EXPORT] No files generated by Claude')
      return NextResponse.json({ error: 'Failed to generate export files' }, { status: 500 })
    }

    // 7. Create ZIP file
    console.log('[EXPORT] Creating ZIP file...')
    const zipBuffer = await createZip(files)
    console.log('[EXPORT] ZIP file created, size:', zipBuffer.length, 'bytes')

    // 8. Track export in database
    console.log('[EXPORT] Tracking export in database...')
    const { error: insertError } = await supabase.from('exports').insert({
      user_id: user.id,
      session_id: sessionId
    })

    if (insertError) {
      console.error('[EXPORT] Error tracking export:', insertError)
      // Don't fail the export, just log the error
    }

    // 9. Return ZIP file
    console.log('[EXPORT] Returning ZIP file to client')
    return new Response(new Uint8Array(zipBuffer), {
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': 'attachment; filename="saas-blueprint.zip"'
      }
    })

  } catch (error) {
    console.error('Export error:', error)
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Export failed. Please try again.' },
      { status: 500 }
    )
  }
}

async function callClaude(buildingPlan: string) {
  console.log('[CALL-CLAUDE] Starting Claude API call...')

  const anthropic = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY
  })

  console.log('[CALL-CLAUDE] Anthropic client created')

  // Load Claude instructions
  console.log('[CALL-CLAUDE] Loading Claude instructions...')
  const instructions = readFileSync(
    join(process.cwd(), 'claude-instructions/claude-instructions.md'),
    'utf-8'
  )
  const kb1 = readFileSync(
    join(process.cwd(), 'claude-instructions/claude-knowledge-base-1.md'),
    'utf-8'
  )
  const kb2 = readFileSync(
    join(process.cwd(), 'claude-instructions/claude-knowledge-base-2.md'),
    'utf-8'
  )

  console.log('[CALL-CLAUDE] Instructions loaded:', {
    instructionsLength: instructions.length,
    kb1Length: kb1.length,
    kb2Length: kb2.length
  })

  const fullInstructions = `${instructions}\n\n---\n\n# Knowledge Base 1\n\n${kb1}\n\n---\n\n# Knowledge Base 2\n\n${kb2}`

  console.log('[CALL-CLAUDE] Calling Anthropic API with Claude Sonnet 4...')
  console.log('[CALL-CLAUDE] Building plan length:', buildingPlan.length)

  const message = await anthropic.messages.create({
    model: "claude-sonnet-4-20250514",
    max_tokens: 8000,
    system: fullInstructions,
    messages: [
      {
        role: "user",
        content: `Transform this comprehensive SaaS building plan into a complete project export package.

# YOUR TASK

You are receiving a detailed 12-section SaaS building plan that includes:
- Product Overview
- Core Architecture with tech stack recommendations
- Database Design
- User Experience Design
- Feature Breakdown (MVP/Growth/Enterprise)
- Business Logic
- AI Integration (if applicable)
- Security & Compliance
- Infrastructure & Scaling
- Implementation Roadmap
- Integration Requirements
- Risk Mitigation

Your job is to transform this into executable Claude Code documentation files that follow the ClaudeOps methodology.

# OUTPUT FORMAT

You MUST format each file exactly as:

## File: [path/to/file.md]
\`\`\`markdown
[Complete file content here - write the full content, not a placeholder]
\`\`\`

# REQUIRED FILES

You must generate at minimum:

1. **README.md** - Project overview
   - Extract product name, problem, solution, target users from Building Plan
   - Include tech stack from "Core Architecture" section
   - Add getting started guide
   - List key features from "Feature Breakdown" section

2. **CLAUDE.md** - Claude Code master instructions
   - Create module links based on architecture
   - Define global constraints from "Security & Compliance" section
   - Include metadata with stack info

3. **modules/Claude-auth.md** - Authentication module
   - Extract from "Security & Compliance" and "Core Architecture" → Authentication
   - Include auth strategy (JWT/OAuth/SSO)
   - Define user roles from "Business Logic" section

4. **modules/Claude-api.md** - API module
   - Extract backend tech from "Core Architecture"
   - Include API endpoints from feature breakdown
   - Define data models from "Database Design"

5. **modules/Claude-database.md** - Database module
   - Extract from "Database Design" section
   - Include multi-tenancy strategy
   - Define core tables and relationships

6. **modules/Claude-ui.md** - UI module
   - Extract from "User Experience Design" section
   - Include frontend tech from "Core Architecture"
   - Define core screens and components

7. **prompts/01-setup-project.md** - Initial setup prompt
   - Extract from "Implementation Roadmap" → Week 1
   - Include tech stack setup commands

8. **prompts/02-implement-auth.md** - Auth implementation prompt
   - Extract auth implementation from "Security & Compliance"

9. **prompts/03-build-mvp-features.md** - MVP features prompt
   - Extract from "Feature Breakdown" → MVP Features section

# CRITICAL RULES

1. **Use the actual content from the building plan** - Don't create generic templates
2. **Reference specific technologies mentioned** - e.g., "Next.js 14", "Supabase Auth", "Claude Sonnet 4"
3. **Include rationale from the plan** - Keep KB references like "(KB1: auth section recommends...)"
4. **Follow the 12-section structure** - Each section contains specific architectural decisions
5. **Make it actionable** - Claude Code must be able to execute these prompts
6. **Be comprehensive** - Don't skip sections or use placeholders

# BUILDING PLAN

${buildingPlan}

---

Now generate the complete export package with all files formatted exactly as specified above.`
      }
    ]
  })

  console.log('[CALL-CLAUDE] Claude response received:', {
    model: message.model,
    stopReason: message.stop_reason,
    tokensUsed: {
      input: message.usage.input_tokens,
      output: message.usage.output_tokens
    }
  })

  return parseClaudeOutput(message.content)
}

function parseClaudeOutput(content: any) {
  // Extract text from Claude response
  const text = typeof content === 'string' ? content : content[0]?.text || ''

  const files = {
    readme: '',
    claude: '',
    modules: {} as Record<string, string>,
    prompts: {} as Record<string, string>
  }

  // Parse files from Claude output
  // Format: ## File: path/to/file.md
  const fileMatches = text.matchAll(/## File: (.+?)\n```(?:markdown)?\n([\s\S]+?)\n```/g)

  let matchCount = 0
  for (const match of fileMatches) {
    matchCount++
    const filePath = match[1].trim()
    const fileContent = match[2]

    console.log(`Parsing file: ${filePath}`)

    if (filePath === 'README.md' || filePath.endsWith('/README.md')) {
      files.readme = fileContent
    } else if (filePath === 'CLAUDE.md' || filePath.endsWith('/CLAUDE.md')) {
      files.claude = fileContent
    } else if (filePath.includes('modules/') || filePath.includes('Claude-')) {
      const moduleName = filePath.split('/').pop()?.replace(/\.(md|MD)$/, '') || 'module'
      files.modules[moduleName] = fileContent
    } else if (filePath.includes('prompts/')) {
      const promptName = filePath.split('/').pop()?.replace(/\.(md|MD)$/, '') || 'prompt'
      files.prompts[promptName] = fileContent
    }
  }

  console.log(`Parsed ${matchCount} files: ${files.readme ? 'README' : ''} ${files.claude ? 'CLAUDE' : ''} modules=${Object.keys(files.modules).length} prompts=${Object.keys(files.prompts).length}`)

  // If no files were parsed, try to extract at least README and CLAUDE from full text
  if (matchCount === 0) {
    console.warn('No files parsed in expected format. Extracting from full text...')
    files.readme = text.substring(0, Math.min(5000, text.length))
    files.claude = 'See README.md for full content.'
  }

  return files
}

async function createZip(files: {
  readme: string
  claude: string
  modules: Record<string, string>
  prompts: Record<string, string>
}) {
  const zip = new JSZip()

  // Add main files
  if (files.readme) {
    zip.file('README.md', files.readme)
  }
  if (files.claude) {
    zip.file('CLAUDE.md', files.claude)
  }

  // Add modules
  if (Object.keys(files.modules).length > 0) {
    const modulesFolder = zip.folder('modules')
    for (const [name, content] of Object.entries(files.modules)) {
      modulesFolder?.file(`${name}.md`, content)
    }
  }

  // Add prompts
  if (Object.keys(files.prompts).length > 0) {
    const promptsFolder = zip.folder('prompts')
    for (const [name, content] of Object.entries(files.prompts)) {
      promptsFolder?.file(`${name}.md`, content)
    }
  }

  return await zip.generateAsync({ type: 'nodebuffer' })
}
